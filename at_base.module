<?php

use \Drupal\at_base\Config\Resolver as ConfigResolver;
use \Drupal\at_base\Config\Config;

require_once dirname(__FILE__) . '/lib/Autoloader.php';
require_once dirname(__FILE__) . '/at_base.hooks.inc';

/**
 * Simple PSR-4 autoloader.
 *  /path/to/%module/Class.php -> \Drupal\%module\Class
 */
spl_autoload_register(function($class) {
  // Only Drupal namespace
  if ($supported = strpos($class, 'Drupal\\') !== FALSE) {
    if ($file = at_id(new \Drupal\at_base\Autoloader($class))->getFile()) {
      require_once $file;
    }
  }
});

/**
 * Identity function, returns its argument unmodified.
 *
 * This is useful almost exclusively as a workaround to an oddity in the PHP
 * grammar -- this is a syntax error:
 *
 *    COUNTEREXAMPLE
 *    new Thing()->doStuff();
 *
 * ...but this works fine:
 *
 *    at_id(new Thing())->doStuff();
 *
 * @param   wild Anything.
 * @return  wild Unmodified argument.
 */
function at_id($x) {
  return $x;
}

/**
 * Service container.
 */
function at_container($service_name) {
  return at_id(new \Drupal\at_base\Container())->get($service_name);
}

/**
 * Helper function for quick cache get/set.
 *
 * @code
 *   $nid = $vid = 1;
 *
 *   $options['ttl'] = '+ 15 minutes';
 *   $options['cache_id'] = "node:{$nid}";
 *   # Same to
 *   $options['id'] = "node:{$nid}";
 *   $options['file'] = '/path/to/file.php;
 *   $options['reset'] = FALSE;
 *   $options['allow_empty'] = TRUE;
 *   $options['tags'] = array('demo', 'testing');
 *
 *   // Use case 1:
 *   $data = at_cache($options, function() use ($nid, $vid) {
 *     return node_load($nid, $vid);
 *   });
 *
 *   // Use case 2:
 *   $data = at_cache($options, 'node_load', array($nid, $vid));
 *
 * @endcode
 *
 * If GODEV constant is defined, at_cache() is by passed rebuild the cache if
 * $_GET['nocache'] is not empty.
 *
 * Tags can be flushed by config. See \Drupal\at_base\Cache\Warming\Entity.php
 *
 * @param  array $options
 * @param  Closure|string $callback
 * @param  array  $arguments
 * @return mixed
 * @see    at_cache_flush_by_tag()
 * @todo   Note about AT_DEV constant
 */
function at_cache($options, $callback, $arguments = array()) {
  require_once dirname(__FILE__) . '/lib/Cache.php';

  if (isset($options['cache_id'])) {
    $options['id'] = $options['cache_id'];
    unset($options['cache_id']);
  }

  return at_id(new \Drupal\at_base\Cache($options, $callback, $arguments))->get();
}

/**
 * Delete cached data by tags.
 *
 * @see at_cache()
 * @param  array  $tags
 * @todo  AND/OR
 */
function at_cache_flush_by_tags($tags = array()) {
  if (empty($tags)) {
    return;
  }

  $items = db_select('at_base_cache_tag', 'atag')
            ->fields('atag', array('bin', 'cid'))
            ->condition('tag', $tags)
            ->execute()
            ->fetchAll();

  foreach ($items as $item) {
    cache_clear_all($item->cid, $item->bin);

    if (function_exists('apc_store')) {
      if (apc_exists("{$item->bin}.{$item->cid}")) {
        apc_delete("{$item->bin}.{$item->cid}");
      }
    }
  }

  db_delete('at_base_cache_tag')
    ->condition('tag', $tags)
    ->execute()
  ;
}

/**
 * Usage
 *
 * // Lookup at /path/to/my_module/config/config.yml > webmaster
 * $webmaster_email = at_config('my_module')->get('webmaster');
 *
 * // Lookup at /path/to/my_module/config/templates.yml > email.notify
 * $mail_notify_template = at_config('my_module', 'templates')->get('email.notify');
 *
 * @param  string  $module    Module name
 * @param  string  $id        Config ID
 * @param  boolean $refresh   Build new cache
 * @return Config
 * @todo   Will remove when at_di.module is ready.
 */
function at_config($module, $id = 'config', $refresh = FALSE) {
  static $config;

  if (!$config) {
    $config = new \Drupal\at_base\Config\Config(new ConfigResolver);
  }

  $config->setModule($module);
  $config->setId($id);

  return $config;
}

/**
 * @todo:
 * Get modules that depends on at.module â€” found
 * `requirements[] = at_base` in .info file
 *
 * @todo check module_implements_write_cache()
 * @see system_list()
 */
function at_modules($base_module = 'at_base', $config_file = '', $reset = FALSE) {
  $options['ttl'] = '+ 1 year';
  $options['bin'] = 'cache_bootstrap';
  $options['cache_id'] = "at_modules:{$base_module}:{$config_file}";
  $options['reset'] = $reset;

  return at_cache($options, function() use ($base_module, $config_file) {
    require_once dirname(__FILE__) . '/lib/Helper/ModulesFetcher.php';
    return at_id(new \Drupal\at_base\Helper\ModulesFetcher($base_module, $config_file))->fetch();
  });
}

/**
 * Check is Drupal system on dev or not.
 *
 * @return boolean
 */
function at_debug() {
  return defined('AT_DEBUG');
}

/**
 * Return if key|upercase/variable is not FALSE|NULL|0.
 */
function at_valid($key) {
  $c = strtoupper($key);
  if (defined($c)) return (boolean) constant($c);
  return (boolean) variable_get($key, FALSE);
}

/**
 * Simpe function for benchmark.
 *
 * Usage:
 *
 *  $callback = function() { $config = at_container('config'); };
 *  print_r(at_timer($callback, 1000));
 *
 * @param  Closure  $callback
 * @param  integer $times
 */
function at_timer($callback, $times = 1) {
  timer_start('at_timer');
  for ($i = 1; $i <= $times; ++$i) {
    $callback();
  }
  return timer_stop('at_timer');
}
