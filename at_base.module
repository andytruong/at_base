<?php

use \Drupal\at_base\Autoloader;
use \Drupal\at_base\Config\Resolver as ConfigResolver;
use \Drupal\at_base\Config\Config;

require_once dirname(__FILE__) . '/lib/AT.php';
require_once dirname(__FILE__) . '/at_base.hooks.inc';
require_once dirname(__FILE__) . '/lib/Autoloader.php';
at_id(new Autoloader())->register();

/**
 * Identity function, returns its argument unmodified.
 *
 * This is useful almost exclusively as a workaround to an oddity in the PHP
 * grammar -- this is a syntax error:
 *
 *    COUNTEREXAMPLE
 *    new Thing()->doStuff();
 *
 * ...but this works fine:
 *
 *    at_id(new Thing())->doStuff();
 *
 * @param   wild Anything.
 * @return  wild Unmodified argument.
 */
function at_id($x) {
  return $x;
}

/**
 * Service container.
 */
function at_container($service_name) {
  return at_id(new \Drupal\at_base\Container())->get($service_name);
}

/**
 * Helper function for quick cache get/set.
 *
 * @code
 *   $nid = $vid = 1;
 *
 *   $options['ttl'] = '+ 15 minutes';
 *   $options['cache_id'] = "node:{$nid}";
 *   # Same to
 *   $options['id'] = "node:{$nid}";
 *   $options['file'] = '/path/to/file.php;
 *   $options['reset'] = FALSE;
 *   $options['allow_empty'] = TRUE;
 *   $options['tags'] = array('demo', 'testing');
 *
 *   // Use case 1:
 *   $data = at_cache($options, function() use ($nid, $vid) {
 *     return node_load($nid, $vid);
 *   });
 *
 *   // Use case 2:
 *   $data = at_cache($options, 'node_load', array($nid, $vid));
 *
 * @endcode
 *
 * If GODEV constant is defined, at_cache() is by passed rebuild the cache if
 * $_GET['nocache'] is not empty.
 *
 * Tags can be flushed by config. See \Drupal\at_base\Cache\Warming\Entity.php
 *
 * @param  array $options
 * @param  Closure|string $callback
 * @param  array  $arguments
 * @return mixed
 * @see    at_cache_flush_by_tag()
 * @todo   Note about AT_DEV constant
 */
function at_cache($options, $callback, $arguments = array()) {
  require_once dirname(__FILE__) . '/lib/Cache.php';

  if (isset($options['cache_id'])) {
    $options['id'] = $options['cache_id'];
    unset($options['cache_id']);
  }

  return at_id(new \Drupal\at_base\Cache($options, $callback, $arguments))->get();
}

/**
 * Delete cached data by tags.
 *
 * @see at_cache()
 * @param  array  $tags
 * @todo  AND/OR
 */
function at_cache_flush_by_tags($tags = array()) {
  if (empty($tags)) {
    return;
  }

  $items = db_select('at_base_cache_tag', 'atag')
            ->fields('atag', array('bin', 'cid'))
            ->condition('tag', $tags)
            ->execute()
            ->fetchAll();

  foreach ($items as $item) {
    cache_clear_all($item->cid, $item->bin);
  }

  db_delete('at_base_cache_tag')
    ->condition('tag', $tags)
    ->execute()
  ;
}

/**
 * Usage
 *
 * // Lookup at /path/to/my_module/config/config.yml > webmaster
 * $webmaster_email = at_config('my_module')->get('webmaster');
 *
 * // Lookup at /path/to/my_module/config/templates.yml > email.notify
 * $mail_notify_template = at_config('my_module', 'templates')->get('email.notify');
 *
 * @param  string  $module    Module name
 * @param  string  $id        Config ID
 * @param  boolean $refresh   Build new cache
 * @return Config
 * @todo   Will remove when at_di.module is ready.
 */
function at_config($module, $id = 'config', $refresh = FALSE) {
  static $config;

  if (!$config) {
    $config = new \Drupal\at_base\Config\Config(new ConfigResolver);
  }

  $config->setModule($module);
  $config->setId($id);

  return $config;
}

/**
 * Get modules that depends on at.module â€” found
 * `requirements[] = at_base` in .info file
 *
 * @see system_list()
 */
function at_modules($base_module = 'at_base', $config_file = '', $reset = FALSE) {
  $options['ttl'] = '+ 1 year';
  $options['bin'] = 'cache_bootstrap';
  $options['cache_id'] = "at_modules:{$base_module}:{$config_file}";
  $options['reset'] = $reset;

  return at_cache($options, function() use ($base_module, $config_file) {
    require_once dirname(__FILE__) . '/lib/Helper/ModulesFetcher.php';
    return at_id(new \Drupal\at_base\Helper\ModulesFetcher($base_module, $config_file))->fetch();
  });
}

/**
 * Generate path for library.
 *
 * @param  string $name
 * @param  string $version
 * @return string
 */
function at_library($name, $version = 'default') {
  $paths = array(conf_path(), 'sites/all');
  foreach ($paths as $path) {
    $return = DRUPAL_ROOT . "/{$path}/libraries/{$name}";
    if ('default' !== $version) {
      $return .= "/{$version}";
    }

    if (FALSE !== @fileowner($return)) {
      return $return;
    }
  }

  throw new Exception("Missing library: {$name} (version {$version})");
}

/**
 * Check is Drupal system on dev or not.
 *
 * @return boolean
 */
function at_debug() {
  return defined('AT_DEBUG');
}

/**
 * Return if key|upercase/variable is not FALSE|NULL|0.
 */
function at_valid($key, $get_value = FALSE) {
  $c = strtoupper($key);
  if (defined($c)) $return = constant($c);
  else $return = variable_get($key, FALSE);
  return $get_value ? $return : (boolean)($return);
}

/**
 * Simpe function for benchmark.
 *
 * Usage:
 *
 *  $callback = function() { $modules = at_modules('at_base'); };
 *  print_r(at_timer($callback, 5000));
 *
 * @param  callable  $callback
 * @param  integer   $times
 */
function at_timer($callback, $times = 1) {
  $memory = memory_get_usage();
  timer_start('at_timer');
  for ($i = 1; $i <= $times; ++$i) {
    $callback();
  }
  $return = timer_stop('at_timer');
  return array('memory' => memory_get_usage() - $memory) + $return;
}

/**
 * Wrapper for class based forms.
 */
function at_form($form, &$form_state) {
  // Get the variables from arguments
  $args       = func_get_args();
  $form       = array_shift($args);
  $form_state = array_shift($args);
  $class      = array_shift($args);
  $args       = reset($args);

  // Build the form
  $class = new \ReflectionClass($class);
  $obj = $class->newInstanceArgs($args);
  $obj->setForm($form);
  $obj->setFormState($form_state);

  $form = $obj->get();
  $form['#at_form'] = array($class->getName(), $args);

  return $form;
}

/**
 * Wrapper for class based forms.
 */
function at_form_validate($form, &$form_state) {
  // Build the form
  list($class, $args) = $form['#at_form'];
  $class = new \ReflectionClass($class);
  $obj = $class->newInstanceArgs($args);
  $obj->setForm($form);
  $obj->setFormState($form_state);

  // Do validate
  $obj->validate();
}

/**
 * Wrapper for class based forms.
 */
function at_form_submit($form, &$form_state) {
  // Build the form
  list($class, $args) = $form['#at_form'];
  $class = new \ReflectionClass($class);
  $obj = $class->newInstanceArgs($args);
  $obj->setForm($form);
  $obj->setFormState($form_state);

  // Do validate
  $obj->submit();
}

/**
 * Page callback for routes.
 *
 * @see \Drupal\at_base\Route\RouteToMenu
 */
function at_route() {
  $args = func_get_args();
  $route = array_pop($args);
  return at_id(new \Drupal\at_base\Route\Controller())->setRoute($route)->execute();
}
